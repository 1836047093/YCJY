# 财务状况实时更新修复说明

## 问题描述

用户反馈了两个严重bug：
1. **财务状况显示¥0.00**：游戏收入没有实时计入财务状况
2. **选择年份后显示一会就消失**：切换年份后，显示一会儿就自动变回当前年份

## 问题根源

### 原有代码的致命缺陷

```kotlin
// ❌ 错误的实现方式
var selectedFinancialYear by remember { mutableIntStateOf(currentYear) }

val financialUpdateKey = remember(games.size, currentYear, currentMonth, currentDay) {
    System.currentTimeMillis()
}

key(financialUpdateKey) {
    // 整个财务计算逻辑...
    // 使用 selectedFinancialYear 进行筛选
    
    CompanyInfoCardWithYearSelector(
        selectedYear = selectedFinancialYear,
        onYearChange = { selectedFinancialYear = it },
        // ...
    )
}
```

**问题分析**：

1. **key() 的工作原理**：
   - `key()` 会强制其包裹的内容完全重新组合
   - 当 `financialUpdateKey` 变化时（比如时间推进），整个 key() 块重新执行
   
2. **状态管理混乱**：
   - `selectedFinancialYear` 在 key() 外面定义
   - 但使用在 key() 里面
   - key() 重新组合时，状态读取出现混乱

3. **具体表现**：
   - 用户切换年份 → `selectedFinancialYear = 2`
   - 时间推进 → `financialUpdateKey` 变化
   - key() 强制重新组合 → 状态丢失或读取错误
   - 年份选择器又变回当前年份
   - 财务数据显示混乱（可能显示¥0.00）

## 解决方案

### 使用 derivedStateOf 实现响应式更新

```kotlin
// ✅ 正确的实现方式
var selectedFinancialYear by remember { mutableIntStateOf(currentYear) }

// 使用 derivedStateOf 计算财务数据，确保依赖变化时自动更新
val financialData = remember(games.size, currentYear, currentMonth, currentDay, selectedFinancialYear) {
    derivedStateOf {
        val releasedGames = games.filter { /* ... */ }
        
        // 计算单机游戏收入
        var singlePlayerRevenue = 0.0
        // ...
        
        // 计算网游收入
        var onlineGameRevenue = 0.0
        // ...
        
        val yearTotalRevenue = singlePlayerRevenue + onlineGameRevenue
        
        Triple(singlePlayerRevenue, onlineGameRevenue, yearTotalRevenue)
    }
}.value

val (singlePlayerRevenue, onlineGameRevenue, yearTotalRevenue) = financialData

CompanyInfoCardWithYearSelector(
    selectedYear = selectedFinancialYear,
    onYearChange = { selectedFinancialYear = it },
    items = listOf(
        "单机收入" to "¥${formatMoneyWithDecimals(singlePlayerRevenue)}",
        "网游收入" to "¥${formatMoneyWithDecimals(onlineGameRevenue)}",
        "总收入" to "¥${formatMoneyWithDecimals(yearTotalRevenue)}"
    )
)
```

### derivedStateOf 的优势

1. **真正的响应式更新**：
   - 依赖项变化时自动重新计算
   - 不会强制整个组件重新组合

2. **正确的状态管理**：
   - `selectedFinancialYear` 状态独立管理
   - 不会被外部强制重组影响

3. **精确的依赖追踪**：
   ```kotlin
   remember(games.size, currentYear, currentMonth, currentDay, selectedFinancialYear) {
       derivedStateOf { /* 计算逻辑 */ }
   }
   ```
   - 任何一项变化都会触发重新计算
   - 但不会破坏其他状态

## 修复效果

### 问题1：财务状况实时更新 ✅

- **修复前**：显示¥0.00或数据不更新
- **修复后**：
  - 游戏发售时，收入立即显示
  - 每日结算后，收入实时更新
  - 切换年份时，正确显示该年收入

### 问题2：年份选择持久化 ✅

- **修复前**：切换年份后一会儿就消失
- **修复后**：
  - 切换年份后，选择保持不变
  - 时间推进不会影响年份选择
  - 手动切换回当前年份前，始终显示选择的年份

## 技术要点

### 1. derivedStateOf vs key()

| 特性 | derivedStateOf | key() |
|------|---------------|-------|
| 重组方式 | 只重新计算值 | 强制重组整个块 |
| 状态保持 | ✅ 保持 | ❌ 可能丢失 |
| 性能 | ✅ 高效 | ⚠️ 开销大 |
| 适用场景 | 派生数据计算 | 需要完全重建的场景 |

### 2. remember + derivedStateOf 组合

```kotlin
val derivedValue = remember(dependency1, dependency2, ...) {
    derivedStateOf {
        // 基于依赖项计算派生值
        // 依赖项变化时自动重新计算
    }
}.value
```

这种模式：
- `remember` 管理 derivedStateOf 的生命周期
- `derivedStateOf` 管理派生值的计算
- `.value` 获取当前计算值

### 3. 响应式更新的依赖管理

```kotlin
remember(games.size, currentYear, currentMonth, currentDay, selectedFinancialYear) {
    derivedStateOf { /* ... */ }
}
```

依赖项包括：
- `games.size`：游戏数量变化（新增/删除游戏）
- `currentYear, currentMonth, currentDay`：游戏时间变化
- `selectedFinancialYear`：用户选择的年份

任何一项变化都会触发重新计算，但不会破坏其他状态。

## 向后兼容

- ✅ 完全向后兼容
- ✅ 不影响存档数据
- ✅ 不需要玩家进行任何操作

## 测试建议

1. **实时更新测试**：
   - 发售一款游戏
   - 点击"下一天"
   - 检查财务状况是否立即显示收入

2. **年份选择测试**：
   - 选择"第1年"
   - 点击"下一天"多次
   - 检查年份选择是否保持"第1年"

3. **多年份测试**：
   - 运行到第2年
   - 在"第1年"和"第2年"之间切换
   - 检查收入数据是否正确显示

4. **多游戏测试**：
   - 发售多款游戏（单机+网游）
   - 检查总收入是否正确汇总

## 总结

这次修复解决了财务状况界面的两个关键问题：

1. **移除了错误的 key() 包裹**：避免强制重组导致的状态混乱
2. **使用 derivedStateOf**：实现真正的响应式更新
3. **正确的依赖管理**：确保所有相关变化都能触发更新

现在财务状况界面：
- ✅ 实时显示游戏收入
- ✅ 年份选择正确保持
- ✅ 性能更高效
- ✅ 代码更清晰易维护

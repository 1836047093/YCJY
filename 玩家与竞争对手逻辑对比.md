# 玩家与竞争对手/子公司逻辑对比分析

## 一、网游系统对比

### 玩家的网游系统（GameRevenueData.kt）

**数据结构**：
```kotlin
data class GameRevenue(
    val playerInterest: Double = 100.0,           // 玩家兴趣值 0-100
    val totalRegisteredPlayers: Long = 0,         // 总注册人数
    val lifecycleProgress: Double = 0.0,          // 生命周期进度 0-100%
    val daysSinceLaunch: Int = 0,                 // 上线天数
    val lastInterestDecayDay: Int = 0             // 上次兴趣值衰减的天数
)
```

**核心逻辑**：

1. **注册数增长**（每日）：
   - 基础增长率：根据评分（2%-5%）
   - 兴趣值影响：0.5-1.15倍
   - 粉丝加成
   - 随机波动：0.9-1.2倍
   - 有上限机制

2. **活跃玩家计算**：
   ```kotlin
   活跃玩家 = 总注册数 × 40% × 兴趣值倍率
   兴趣值倍率 = 1.0 (70%+) / 0.7 (50-70%) / 0.4 (30-50%) / 0.2 (30%-)
   ```

3. **兴趣值系统**：
   - 生命周期：365天
   - 每90天衰减一次
   - 衰减率：8% (成长期) → 15% (成熟期) → 25% (衰退期) → 35% (末期)
   - 更新恢复：25% → 15% → 8% → 0%

4. **上线天数**：
   - 每天+1
   - 用于计算生命周期进度和兴趣值衰减

---

### 竞争对手/子公司的网游系统（CompetitorData.kt / SubsidiaryData.kt）

**数据结构**：
```kotlin
data class CompetitorGame(
    val activePlayers: Long = 0,                  // 活跃玩家数
    val totalRevenue: Double = 0.0,               // 累计总收入
    val monetizationRevenue: Double = 0.0         // 累计付费内容收入
    // ❌ 没有 totalRegisteredPlayers
    // ❌ 没有 playerInterest
    // ❌ 没有 lifecycleProgress
    // ❌ 没有 daysSinceLaunch
)
```

**核心逻辑**：

1. **活跃玩家变化**（竞争对手，每月）：
   - 基础增长率：根据评分（0.3%-5%）
   - 随机波动：0.7-1.3倍
   - 追赶机制（旧存档）
   - **❌ 没有兴趣值影响**
   - **❌ 没有总注册数概念**

2. **活跃玩家变化**（子公司，每月）：
   ```kotlin
   新活跃玩家 = 当前活跃玩家 × 0.98  // 固定衰减2%
   ```
   - **❌ 完全简化，没有兴趣值系统**
   - **❌ 没有生命周期概念**

3. **兴趣值系统**：
   - **❌ 完全没有**

4. **更新恢复机制**：
   - **❌ 完全没有**

---

## 二、单机游戏系统对比

### 玩家的单机游戏系统（GameRevenueData.kt）

**销量计算**：
- 首发销量：基于评分、平台、宣传指数、粉丝数
- 后续销量：逐日衰减，有粉丝加成

**我没有找到玩家的单机游戏持续销量增长逻辑**（需要确认是否存在）

---

### 竞争对手的单机游戏系统（CompetitorData.kt）

**每月销量增长**：
```kotlin
// 基础增长率（根据评分）
val baseGrowthRate = when {
    game.rating >= 9.0f -> Random.nextDouble(1.2, 2.5)   // 1.2%-2.5%
    game.rating >= 8.5f -> Random.nextDouble(0.9, 1.8)   // 0.9%-1.8%
    game.rating >= 8.0f -> Random.nextDouble(0.6, 1.2)   // 0.6%-1.2%
    game.rating >= 7.5f -> Random.nextDouble(0.4, 0.9)   // 0.4%-0.9%
    game.rating >= 7.0f -> Random.nextDouble(0.3, 0.6)   // 0.3%-0.6%
    else -> Random.nextDouble(0.15, 0.4)                 // 0.15%-0.4%
}

// 计算增长
val proportionalGrowth = (game.salesCount * baseGrowthRate / 100.0).toLong()

// 保底增长
val minGrowth = when {
    game.rating >= 9.0f -> Random.nextInt(5000, 12000)   // 5000-12000/月
    game.rating >= 8.5f -> Random.nextInt(3000, 8000)    // 3000-8000/月
    game.rating >= 8.0f -> Random.nextInt(2000, 5000)    // 2000-5000/月
    game.rating >= 7.0f -> Random.nextInt(1000, 3000)    // 1000-3000/月
    else -> Random.nextInt(300, 1200)                    // 300-1200/月
}.toLong()

// 取较大值，但不超过当前销量的8%
val salesGrowth = maxOf(proportionalGrowth, minGrowth).coerceAtMost(maxGrowth)
```

---

### 子公司的单机游戏系统（SubsidiaryData.kt）

**每月销量增长**：
```kotlin
val newSales = (game.salesCount * 0.01).toLong().coerceAtLeast(10L)  // 固定1%，最少10份
```

- **❌ 完全简化，固定1%**
- **❌ 没有评分影响**
- **❌ 没有保底机制**

---

## 三、核心问题总结

### ❌ 子公司和竞争对手缺失的系统

1. **总注册数系统**：
   - 玩家有 `totalRegisteredPlayers`
   - 竞争对手/子公司只有 `activePlayers`

2. **兴趣值系统**：
   - 玩家有完整的兴趣值衰减和恢复机制
   - 竞争对手/子公司完全没有

3. **生命周期系统**：
   - 玩家有 `lifecycleProgress`（0-100%）
   - 竞争对手/子公司完全没有

4. **上线天数追踪**：
   - 玩家有 `daysSinceLaunch`
   - 竞争对手/子公司完全没有

5. **更新恢复机制**：
   - 玩家更新游戏可恢复兴趣值
   - 竞争对手/子公司完全没有

### ❌ 逻辑差异

| 维度 | 玩家 | 竞争对手 | 子公司 |
|------|------|----------|--------|
| **网游注册数** | ✅ 每日增长，兴趣值影响 | ❌ 无此概念 | ❌ 无此概念 |
| **网游活跃玩家** | ✅ 注册数×40%×兴趣倍率 | ❌ 直接增长（无兴趣值） | ❌ 固定衰减2% |
| **兴趣值系统** | ✅ 完整系统 | ❌ 无 | ❌ 无 |
| **生命周期** | ✅ 365天，分4阶段 | ❌ 无 | ❌ 无 |
| **更新恢复** | ✅ 根据阶段恢复 | ❌ 无 | ❌ 无 |
| **单机销量增长** | ❓ 需确认 | ✅ 复杂逻辑 | ❌ 固定1% |

---

## 四、需要修改的内容

### 1. 数据结构修改

为 `CompetitorGame` 添加字段：
```kotlin
data class CompetitorGame(
    // ... 现有字段 ...
    val totalRegisteredPlayers: Long = 0,     // 总注册人数（网游）
    val playerInterest: Double = 100.0,       // 玩家兴趣值（网游）
    val lifecycleProgress: Double = 0.0,      // 生命周期进度（网游）
    val daysSinceLaunch: Int = 0,             // 上线天数（网游）
    val lastInterestDecayDay: Int = 0         // 上次兴趣值衰减天数（网游）
)
```

### 2. 网游更新逻辑

**竞争对手月度更新**应该使用与玩家相同的逻辑：
```kotlin
// 1. 每日更新上线天数
daysSinceLaunch += 1

// 2. 计算生命周期进度
lifecycleProgress = calculateLifecycleProgress(daysSinceLaunch)

// 3. 每90天衰减兴趣值
if (daysSinceLaunch / 90 > lastInterestDecayDay / 90) {
    playerInterest = calculateInterestDecay(playerInterest, lifecycleProgress)
    lastInterestDecayDay = daysSinceLaunch
}

// 4. 注册数增长（每日）
val baseGrowthRate = 根据评分（2%-5%）
val interestMultiplier = 根据兴趣值（0.5-1.15）
val newRegistrations = 前一天注册数 × baseGrowthRate × interestMultiplier

totalRegisteredPlayers += newRegistrations

// 5. 活跃玩家计算
activePlayers = totalRegisteredPlayers × 0.4 × 兴趣值倍率
```

### 3. 单机游戏更新逻辑

**子公司单机游戏**应该使用与竞争对手相同的逻辑：
```kotlin
// 使用竞争对手的复杂销量增长逻辑
val baseGrowthRate = 根据评分（0.15%-2.5%）
val proportionalGrowth = 当前销量 × baseGrowthRate
val minGrowth = 保底增长（300-12000/月）
val salesGrowth = max(proportionalGrowth, minGrowth).coerceAtMost(maxGrowth)

salesCount += salesGrowth
```

### 4. 更新游戏功能

为竞争对手/子公司添加更新游戏功能：
```kotlin
// 更新后恢复兴趣值
playerInterest = recoverInterestAfterUpdate(playerInterest, lifecycleProgress)
```

---

## 五、修改优先级

### 🔴 高优先级（必须改）
1. ✅ **服务器成本**：已修复，使用与玩家相同的系统
2. ❌ **网游兴趣值系统**：核心机制，影响收入计算
3. ❌ **网游总注册数**：核心数据，与兴趣值系统关联

### 🟡 中优先级（建议改）
4. ❌ **单机销量增长**：子公司过于简化（固定1%）
5. ❌ **更新恢复机制**：影响游戏策略深度

### 🟢 低优先级（可选）
6. ⚪ **生命周期显示**：主要是数据展示，不影响核心逻辑

---

## 六、向后兼容性

所有修改都需要考虑向后兼容：
- 旧存档缺失的字段使用默认值
- 根据发售日期计算初始兴趣值（模拟历史衰减）
- 根据当前活跃玩家反推总注册数

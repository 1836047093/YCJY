# 收购竞争对手后存档加载问题修复说明

## 问题描述
收购了竞争对手后，退出存档再加载存档，被收购的竞争对手又重新出现在了排行榜中。

## 问题原因

### 根本原因
在 `MainActivity.kt` 中，竞争对手初始化逻辑有问题：

```kotlin
// 问题代码
LaunchedEffect(Unit) {
    if (competitors.isEmpty()) {
        // 只要competitors为空，就重新生成
        competitors = CompetitorManager.generateInitialCompetitors(...)
    }
}
```

**问题分析**：
1. 收购成功后，`competitors` 列表被正确更新（移除被收购的公司）
2. 存档保存时，`competitors` 列表被正确保存（包含更新后的列表）
3. 但是读档时，`competitors` 被初始化为存档中的值（第2260行）
4. 然后 `LaunchedEffect(Unit)` 检查到 `competitors.isEmpty()`（可能是状态还没有完全同步）
5. 重新生成了9个竞争对手，覆盖了存档中的正确数据

### 逻辑错误
- **依赖检查错误**：使用 `LaunchedEffect(Unit)` 而不是 `LaunchedEffect(saveData)`
- **判断条件错误**：只检查 `competitors.isEmpty()`，没有区分是新游戏还是读档
- **没有区分场景**：新游戏和读档都使用相同的逻辑，导致读档时错误地重新生成竞争对手

## 修复方案

### 修改内容
**文件**：`app/src/main/java/com/example/yjcy/MainActivity.kt`

#### 修复前
```kotlin
// 初始化竞争对手（只执行一次）
LaunchedEffect(Unit) {
    if (competitors.isEmpty()) {
        // 生成初始竞争对手（新游戏或继承后的存档都会触发）
        competitors = CompetitorManager.generateInitialCompetitors(
            companyName, 
            currentYear, 
            currentMonth
        )
        Log.d("MainActivity", "初始化竞争对手：生成${competitors.size}家竞争公司")
    }
}
```

#### 修复后
```kotlin
// 初始化竞争对手（只执行一次，且只在存档中没有竞争对手时才生成）
LaunchedEffect(saveData) {
    if (saveData == null) {
        // 新游戏：生成初始竞争对手
        if (competitors.isEmpty()) {
            competitors = CompetitorManager.generateInitialCompetitors(
                companyName, 
                currentYear, 
                currentMonth
            )
            Log.d("MainActivity", "初始化竞争对手：生成${competitors.size}家竞争公司")
        }
    } else {
        // 读档：从存档中恢复竞争对手列表
        // 注意：即使存档中competitors为空（所有对手都被收购），也不应该重新生成
        competitors = saveData.competitors
        Log.d("MainActivity", "从存档恢复竞争对手：${competitors.size}家竞争公司")
    }
}
```

### 关键改进

1. **依赖检查修复**：
   - 从 `LaunchedEffect(Unit)` 改为 `LaunchedEffect(saveData)`
   - 确保在存档数据加载后执行初始化逻辑

2. **场景区分**：
   - **新游戏**（`saveData == null`）：只有在 `competitors.isEmpty()` 时才生成初始竞争对手
   - **读档**（`saveData != null`）：直接从存档中恢复 `competitors` 列表，**即使为空也不重新生成**

3. **逻辑清晰**：
   - 新游戏：检查并生成竞争对手
   - 读档：无条件使用存档中的竞争对手列表
   - 保护已收购状态：即使所有竞争对手都被收购（列表为空），也不重新生成

## 修复效果

### 修复前
1. 收购竞争对手A ✅
2. 存档保存（competitors列表中不包含A）✅
3. 退出游戏 ✅
4. 加载存档 ❌
5. 初始化逻辑检测到 `competitors.isEmpty()`（可能是状态同步问题）
6. 重新生成9个竞争对手 ❌
7. 被收购的竞争对手A重新出现 ❌

### 修复后
1. 收购竞争对手A ✅
2. 存档保存（competitors列表中不包含A）✅
3. 退出游戏 ✅
4. 加载存档 ✅
5. 初始化逻辑检测到 `saveData != null`（读档模式）
6. 直接从存档中恢复 `competitors` 列表 ✅
7. 被收购的竞争对手A不会重新出现 ✅

## 技术细节

### 竞争对手状态管理

#### 初始化（第2260行）
```kotlin
var competitors by remember { mutableStateOf(saveData?.competitors ?: emptyList()) }
```

#### 收购成功（第4021行）
```kotlin
competitors = competitors.filter { it.id != acquiredCompany.id }
```

#### 存档保存（第2804行、第8047行）
```kotlin
competitors = competitors,
```

#### 存档加载（修复后，第2580行）
```kotlin
competitors = saveData.competitors
```

### 关键原则

1. **存档优先**：读档时，始终使用存档中的 `competitors` 列表
2. **不重新生成**：即使存档中 `competitors` 为空（所有对手都被收购），也不应该重新生成
3. **状态同步**：使用 `LaunchedEffect(saveData)` 确保在存档数据加载后执行初始化

## 修改文件

- **MainActivity.kt**
  - 第2565-2583行：修复竞争对手初始化逻辑

## 测试建议

### 测试场景1：新游戏
1. 创建新游戏
2. 验证生成了9个竞争对手 ✅

### 测试场景2：收购后存档
1. 收购1个竞争对手
2. 手动存档
3. 退出游戏
4. 加载存档
5. 验证被收购的竞争对手没有重新出现 ✅
6. 验证剩余竞争对手数量正确（8个）✅

### 测试场景3：收购所有竞争对手
1. 收购所有9个竞争对手
2. 手动存档（competitors列表为空）
3. 退出游戏
4. 加载存档
5. 验证不会重新生成竞争对手 ✅
6. 验证排行榜不显示任何竞争对手 ✅

## 总结

本次修复解决了收购竞争对手后存档加载时竞争对手重新出现的问题：
- ✅ 读档时正确恢复竞争对手列表
- ✅ 保护已收购状态，不重新生成被收购的竞争对手
- ✅ 区分新游戏和读档场景，使用正确的初始化逻辑
- ✅ 即使所有竞争对手都被收购，也不重新生成

现在收购竞争对手后，存档加载时会正确保持收购状态，被收购的竞争对手不会再重新出现！


# 竞争对手和子公司逻辑对齐修复说明

## 修复日期
2025-01-26

## 问题描述

用户发现竞争对手和子公司的游戏逻辑与玩家使用的逻辑不一致，具体表现为：

### ❌ 网游系统缺失

**玩家系统**：
- ✅ 有总注册数（`totalRegisteredPlayers`）
- ✅ 有兴趣值系统（`playerInterest`）
- ✅ 有生命周期进度（`lifecycleProgress`）
- ✅ 每90天衰减兴趣值
- ✅ 更新游戏可恢复兴趣值
- ✅ 活跃玩家 = 注册数 × 40% × 兴趣倍率

**竞争对手/子公司旧系统**：
- ❌ 只有活跃玩家数，无总注册数概念
- ❌ 没有兴趣值系统
- ❌ 没有生命周期概念
- ❌ 竞争对手：活跃玩家直接增长（无兴趣值影响）
- ❌ 子公司：活跃玩家固定衰减2%

### ❌ 单机游戏系统差异

**竞争对手系统**：
- ✅ 复杂的销量增长逻辑（评分影响 + 保底增长）
- ✅ 根据评分动态调整增长率（0.15%-2.5%）

**子公司旧系统**：
- ❌ 固定1%增长，过于简化
- ❌ 没有评分影响
- ❌ 没有保底机制

## 解决方案

### 1. 数据结构修改

为 `CompetitorGame` 添加网游兴趣值系统字段：

```kotlin
data class CompetitorGame(
    // ... 现有字段 ...
    
    // 🆕 网游兴趣值系统（与玩家系统对齐）
    val totalRegisteredPlayers: Long = 0,     // 总注册人数（仅网游）
    val playerInterest: Double = 100.0,       // 玩家兴趣值 0-100（仅网游）
    val lifecycleProgress: Double = 0.0,      // 生命周期进度 0-100%（仅网游）
    val daysSinceLaunch: Int = 0,             // 上线天数（仅网游）
    val lastInterestDecayDay: Int = 0         // 上次兴趣值衰减的天数（仅网游）
)
```

### 2. 初始化逻辑修改

#### 新发售游戏（`generateNewGame`）

**网游初始化**：
```kotlin
// 根据活跃玩家数反推总注册数
// 活跃玩家 = 总注册数 × 40% × 兴趣倍率
// 初始兴趣值100%，兴趣倍率1.0
initialTotalRegistered = (players / 0.4).toLong()
initialPlayerInterest = 100.0
initialLifecycleProgress = 0.0
initialDaysSinceLaunch = 0
```

#### 历史游戏（`generateCompanyGames`）

**模拟历史兴趣值衰减**：
```kotlin
// 1. 计算上线天数
initialDaysSinceLaunch = monthsSinceRelease * 30

// 2. 计算生命周期进度
initialLifecycleProgress = (daysSinceLaunch / 365.0 * 100).coerceIn(0.0, 100.0)

// 3. 模拟历史兴趣值衰减（每90天衰减一次）
initialPlayerInterest = 100.0
val decayCount = daysSinceLaunch / 90
for (i in 0 until decayCount) {
    val decayRate = when (生命周期阶段) {
        成长期 (0-30%) -> 8.0
        成熟期 (30-70%) -> 15.0
        衰退期 (70-90%) -> 25.0
        末期 (90%+) -> 35.0
    }
    playerInterest -= decayRate
}

// 4. 根据活跃玩家数和兴趣值反推总注册数
val interestMultiplier = when (playerInterest) {
    >= 70% -> 1.0
    >= 50% -> 0.7
    >= 30% -> 0.4
    else -> 0.2
}
totalRegistered = activePlayers / (0.4 * interestMultiplier)
```

### 3. 月度更新逻辑修改

#### 竞争对手网游更新（`updateCompetitors`）

**完整的兴趣值系统逻辑**：

```kotlin
// 1. 更新上线天数（每月30天）
daysSinceLaunch += 30

// 2. 计算生命周期进度
lifecycleProgress = (daysSinceLaunch / 365.0 * 100).coerceIn(0.0, 100.0)

// 3. 检查是否需要衰减兴趣值（每90天衰减一次）
if ((daysSinceLaunch / 90) > (lastDecayDay / 90)) {
    val decayRate = when (生命周期阶段) {
        成长期 -> 8%, 成熟期 -> 15%, 衰退期 -> 25%, 末期 -> 35%
    }
    playerInterest -= decayRate
    lastDecayDay = daysSinceLaunch
}

// 4. 计算注册数增长（每日 × 30天）
for (day in 1..30) {
    baseGrowthRate = when (评分) {
        >= 8.5 -> 5%, >= 8.0 -> 4%, >= 7.0 -> 3%, else -> 2%
    }
    
    interestMultiplier = when (playerInterest) {
        >= 80% -> 1.15, >= 70% -> 1.0, >= 50% -> 0.85,
        >= 30% -> 0.7, else -> 0.5
    }
    
    dailyRegistrations = totalRegistered * baseGrowthRate * interestMultiplier * 0.01
    totalRegistered += dailyRegistrations
}

// 5. 计算活跃玩家数（总注册数 × 40% × 兴趣倍率）
activePlayers = totalRegistered * 0.4 * interestMultiplier

// 6. 计算本月收入
monthlyRevenue = calculateMonetizationRevenue(activePlayers, theme)
```

#### 子公司网游更新（`SubsidiaryManager.updateMonthlyData`）

使用**与竞争对手完全相同**的逻辑（见上文）。

#### 子公司单机游戏更新

使用**与竞争对手相同**的复杂销量增长逻辑：

```kotlin
// 基础增长率（根据评分）
baseGrowthRate = when (评分) {
    >= 9.0 -> 1.2%-2.5%, >= 8.5 -> 0.9%-1.8%,
    >= 8.0 -> 0.6%-1.2%, >= 7.5 -> 0.4%-0.9%,
    >= 7.0 -> 0.3%-0.6%, else -> 0.15%-0.4%
}

// 按比例增长
proportionalGrowth = salesCount * baseGrowthRate / 100

// 保底增长
minGrowth = when (评分) {
    >= 9.0 -> 5000-12000/月, >= 8.5 -> 3000-8000/月,
    >= 8.0 -> 2000-5000/月, >= 7.0 -> 1000-3000/月,
    else -> 300-1200/月
}

// 取较大值，但不超过当前销量的8%
salesGrowth = max(proportionalGrowth, minGrowth).coerceAtMost(salesCount * 0.08)
```

### 4. 向后兼容性处理

#### 旧存档数据修复（MainActivity.kt）

在读档后自动修复旧存档数据：

```kotlin
// 修复竞争对手
competitors = CompetitorManager.fixLegacyCompetitorGames(
    competitors, currentYear, currentMonth
)

// 修复子公司
subsidiaries = subsidiaries.map { subsidiary ->
    val fixedGames = subsidiary.games.map { game ->
        if (game.businessModel == ONLINE_GAME && game.totalRegisteredPlayers == 0L) {
            // 计算历史数据并设置合理的初始值
            game.copy(
                totalRegisteredPlayers = ...,
                playerInterest = ...,
                lifecycleProgress = ...,
                daysSinceLaunch = ...,
                lastInterestDecayDay = ...
            )
        } else {
            game
        }
    }
    subsidiary.copy(games = fixedGames)
}
```

**修复逻辑**：
1. 检测：`totalRegisteredPlayers == 0` 表示旧存档
2. 根据发售日期计算上线天数和生命周期进度
3. 模拟历史兴趣值衰减
4. 根据当前活跃玩家数和兴趣值反推总注册数

## 修复效果

### 网游系统

#### 旧系统问题
- 竞争对手：活跃玩家简单增长，无衰减
- 子公司：活跃玩家固定衰减2%
- **结果**：玩家数变化不真实，缺乏策略深度

#### 新系统效果
- ✅ 总注册数每日增长（受评分和兴趣值影响）
- ✅ 兴趣值每90天衰减（8%-35%）
- ✅ 活跃玩家 = 注册数 × 40% × 兴趣倍率
- ✅ 与玩家面临相同的兴趣值衰减挑战
- ✅ 更新游戏可恢复兴趣值（未来可实现）

**数值示例**（9.0分网游，初始20万活跃玩家）：

| 月份 | 注册数 | 兴趣值 | 活跃倍率 | 活跃玩家 |
|------|--------|--------|----------|----------|
| 0（初始）| 50万 | 100% | 1.0 | 20万 |
| 3（成长期）| 58万 | 92% | 1.0 | 21.3万 |
| 6（成长期）| 68万 | 84% | 1.0 | 22.8万 |
| 9（衰减）| 79万 | 76% | 1.0 | 31.6万 |
| 12（成熟期）| 92万 | 61% | 0.7 | 25.8万 ⚠️开始下降 |

### 单机游戏系统

#### 旧系统问题（子公司）
- 固定1%增长，过于简化
- 与竞争对手逻辑不一致

#### 新系统效果
- ✅ 使用与竞争对手相同的复杂逻辑
- ✅ 高评分游戏增长更快（1.2%-2.5%）
- ✅ 有保底增长机制（300-12000/月）
- ✅ 有增长上限（不超过8%）

**数值示例**（9.0分单机，初始10万销量）：

| 月份 | 增长率 | 保底增长 | 实际增长 | 累计销量 |
|------|--------|----------|----------|----------|
| 1 | 1.2%-2.5% | 5000-12000 | ~8000 | 10.8万 |
| 2 | 1.2%-2.5% | 5000-12000 | ~8500 | 11.65万 |
| 3 | 1.2%-2.5% | 5000-12000 | ~9000 | 12.55万 |
| 6 | 1.2%-2.5% | 5000-12000 | ~10500 | 16.2万 |
| 12 | 1.2%-2.5% | 5000-12000 | ~12000 | 26.5万 |

## 游戏平衡影响

### ✅ 优点

1. **公平性**：
   - 竞争对手和子公司使用与玩家完全相同的游戏逻辑
   - 面临相同的兴趣值衰减压力
   - 服务器成本也已对齐（见"子公司服务器成本修复说明.md"）

2. **真实性**：
   - 网游有生命周期概念
   - 兴趣值自然衰减符合真实游戏市场
   - 单机销量增长更符合长尾效应

3. **策略深度**：
   - 收购决策需要评估游戏生命周期
   - 需要定期更新游戏恢复兴趣值（未来功能）
   - 高评分游戏价值更高

### ⚠️ 挑战

1. **竞争对手可能变弱**：
   - 老游戏兴趣值低，活跃玩家可能大幅下降
   - 但这符合真实市场规律

2. **子公司可能更难盈利**：
   - 网游活跃玩家可能减少（兴趣值衰减）
   - 但单机销量增长会更快（评分高）

3. **旧存档数值变化**：
   - 读档后，竞争对手/子公司网游数据会补全
   - 下次月结算开始使用新逻辑
   - 可能出现活跃玩家数波动

## 技术细节

### 修改文件

1. **CompetitorData.kt**（竞争对手）
   - 数据结构：添加5个兴趣值系统字段
   - `generateNewGame()`：新游戏初始化
   - `generateCompanyGames()`：历史游戏初始化
   - `updateCompetitors()`：月度更新逻辑
   - `fixLegacyCompetitorGames()`：旧存档修复

2. **SubsidiaryData.kt**（子公司）
   - `updateMonthlyData()`：月度更新逻辑（网游+单机）

3. **MainActivity.kt**（主逻辑）
   - 读档后调用修复函数

### 关键算法

#### 兴趣值衰减计算

```kotlin
fun calculateInterestDecay(lifecycleProgress: Double): Double {
    return when {
        lifecycleProgress < 30.0 -> 8.0   // 成长期：每3个月衰减8%
        lifecycleProgress < 70.0 -> 15.0  // 成熟期：每3个月衰减15%
        lifecycleProgress < 90.0 -> 25.0  // 衰退期：每3个月衰减25%
        else -> 35.0                      // 末期：每3个月衰减35%
    }
}
```

#### 活跃玩家计算

```kotlin
fun calculateActivePlayers(
    totalRegistered: Long,
    playerInterest: Double
): Long {
    // 兴趣值影响活跃率
    val interestMultiplier = when {
        playerInterest >= 70.0 -> 1.0    // 正常
        playerInterest >= 50.0 -> 0.7    // 下降30%
        playerInterest >= 30.0 -> 0.4    // 下降60%
        else -> 0.2                      // 下降80%
    }
    
    // 活跃玩家 = 总注册数 × 40% × 兴趣倍率
    return (totalRegistered * 0.4 * interestMultiplier).toLong()
}
```

#### 注册数增长计算

```kotlin
fun calculateDailyRegistrations(
    totalRegistered: Long,
    rating: Float,
    playerInterest: Double
): Long {
    // 基础增长率（根据评分）
    val baseGrowthRate = when {
        rating >= 8.5f -> 0.05  // 5%
        rating >= 8.0f -> 0.04  // 4%
        rating >= 7.0f -> 0.03  // 3%
        else -> 0.02            // 2%
    }
    
    // 兴趣值影响增长
    val interestMultiplier = when {
        playerInterest >= 80.0 -> 1.15  // +15%
        playerInterest >= 70.0 -> 1.0   // 正常
        playerInterest >= 50.0 -> 0.85  // -15%
        playerInterest >= 30.0 -> 0.7   // -30%
        else -> 0.5                     // -50%
    }
    
    return (totalRegistered * baseGrowthRate * interestMultiplier * 0.01).toLong()
}
```

## ✅ 已实现：更新游戏恢复兴趣值

### 实现逻辑

**触发条件**：
- 网游兴趣值低于50%
- 生命周期进度<90%（末期无法恢复）

**更新概率**（兴趣值越低，概率越高）：
- 兴趣值<30%：30%概率
- 兴趣值30-40%：20%概率
- 兴趣值40-50%：10%概率

**恢复量**（与玩家系统相同）：
- 成长期（0-30%）：恢复25%
- 成熟期（30-70%）：恢复15%
- 衰退期（70-90%）：恢复8%
- 末期（90%+）：无法恢复

**效果**：
- **竞争对手**：自动更新游戏，生成新闻事件
- **子公司**：自动更新游戏，显示日志信息

### 代码实现

**竞争对手**（CompetitorData.kt）：
```kotlin
// 在月度更新的网游逻辑中
if (newPlayerInterest < 50.0 && newLifecycleProgress < 90.0) {
    val updateProbability = when {
        newPlayerInterest < 30.0 -> 0.30
        newPlayerInterest < 40.0 -> 0.20
        else -> 0.10
    }
    
    if (Random.nextDouble() < updateProbability) {
        val recoveryAmount = when {
            newLifecycleProgress < 30.0 -> 25.0
            newLifecycleProgress < 70.0 -> 15.0
            else -> 8.0
        }
        finalPlayerInterest = (newPlayerInterest + recoveryAmount).coerceIn(0.0, 100.0)
        
        // 生成更新游戏新闻
        newsList.add(CompetitorNews(..., type = NewsType.GAME_UPDATE))
    }
}
```

**子公司**（SubsidiaryData.kt）：
使用完全相同的逻辑。

### 游戏效果示例

**9.0分网游，兴趣值降至45%**：
- 触发概率：10%
- 如果触发（成熟期）：恢复15% → 60%
- 活跃玩家：从70%倍率恢复到100%倍率
- 效果明显：活跃玩家数可能增加40%

**老游戏（末期90%+）**：
- ❌ 无法通过更新恢复
- 符合真实游戏生命周期

---

## 未来扩展

### 可能的功能增强

1. **赛事影响兴趣值**：
   - 举办赛事提升兴趣值
   - 获得GVA奖项提升兴趣值

2. **IP影响**：
   - 强IP游戏初始兴趣值更高
   - 兴趣值衰减更慢

3. **粉丝影响**：
   - 公司粉丝数影响注册数增长
   - 已在玩家系统实现，竞争对手可参考

## 向后兼容性

### ✅ 完全兼容

- **新游戏**：使用新系统，数据完整
- **旧存档**：自动修复，补充缺失字段
- **数据结构**：字段有默认值，不会报错

### ⚠️ 注意事项

1. **首次读档**：
   - 会看到日志："✅ 已修复旧存档的竞争对手游戏数据"
   - 数据补全后自动保存

2. **数值变化**：
   - 下次月结算开始使用新逻辑
   - 竞争对手网游可能出现活跃玩家波动
   - 子公司网游也会有相同变化

3. **不可逆**：
   - 修复后无法回退到旧逻辑
   - 建议提前备份存档

## 测试建议

### 1. 新游戏测试
- 创建新游戏，观察竞争对手和子公司初始数据
- 验证兴趣值系统字段是否正确初始化

### 2. 月度更新测试
- 等待1-2个月
- 观察竞争对手网游活跃玩家变化
- 观察子公司网游活跃玩家变化
- 观察子公司单机销量增长

### 3. 兴趣值衰减测试
- 等待3个月（90天）
- 观察竞争对手网游兴趣值是否衰减
- 验证活跃玩家数是否相应下降

### 4. 旧存档兼容性测试
- 加载旧存档
- 检查日志是否显示"已修复"
- 观察下次月结算后的数据变化

## 相关文档

- **服务器成本修复**：`子公司服务器成本修复说明.md`
- **逻辑对比分析**：`玩家与竞争对手逻辑对比.md`
- **子公司游戏收入修复**：`子公司游戏收入修复说明.md`

## 总结

此次修复**彻底对齐**了竞争对手/子公司与玩家的游戏逻辑：

✅ **网游系统**：完整的兴趣值系统（总注册数、兴趣值、生命周期）
✅ **单机系统**：复杂的销量增长逻辑（评分影响、保底增长）
✅ **服务器成本**：使用玩家相同的租用系统
✅ **向后兼容**：旧存档自动修复

**结果**：竞争对手和子公司现在使用与玩家**完全相同**的游戏逻辑！
